// Generated by CoffeeScript 1.8.0
(function() {
  var App;

  App = typeof exports !== "undefined" && exports !== null ? exports : window;

  App.coffeeMind = App.coffeeMind || {};

  App.coffeeMind.display = (function() {
    var addAnimation, animateCursor, animations, availableColorsCtx, availableColoursCount, canvas, clearImage, cols, createAvailableColoursElement, createBackground, createSolutionElement, ctx, cursor, cycle, drawAvailableColours, drawCheckColors, drawSolution, explode, gameOver, hideSolution, imagePath, imageSize, images, init, levelUp, myDrawImage, numColors, previousCycle, renderAnimations, renderCursor, reset, rows, setup, solutionCanvas, solutionCtx, srcPath, unRenderCursor, _$, _options;
    _$ = {};
    canvas = {};
    _options = {};
    ctx = {};
    cols = 0;
    rows = 0;
    availableColoursCount = 0;
    imageSize = 0;
    solutionCtx = {};
    availableColorsCtx = {};
    solutionCanvas = {};
    previousCycle = {};
    cursor = {};
    animations = [];
    images = [];
    numColors = 0;
    srcPath = "";
    imagePath = "";
    setup = function($) {
      var $boardElement;
      _$ = $;
      _options = App.settings;
      $boardElement = _$("#game-screen .game-board");
      cols = _options.cols;
      rows = _options.rows;
      srcPath = _options.srcPath;
      numColors = _options.numColors;
      availableColoursCount = _options.availableColours;
      imageSize = _options.imageSize;
      imagePath = srcPath + "images/forms_" + imageSize + ".png";
      canvas = document.createElement("canvas");
      ctx = canvas.getContext("2d");
      _$(canvas).addClass("board");
      canvas.width = cols * imageSize + imageSize;
      canvas.height = rows * imageSize;
      $boardElement.append(createBackground());
      $boardElement.append(canvas);
      createSolutionElement();
      createAvailableColoursElement();
      images = _options.images;
      previousCycle = Date.now();
      requestAnimationFrame(cycle);
      return null;
    };
    cycle = function(time) {
      animateCursor(time);
      renderAnimations(time, previousCycle);
      previousCycle = time;
      requestAnimationFrame(cycle);
      return null;
    };
    levelUp = function(callback) {
      var beforeMethod, renderMethod;
      beforeMethod = function(pos) {
        var x, y, _i, _results;
        _results = [];
        for (y = _i = 0; 0 <= rows ? _i < rows : _i > rows; y = 0 <= rows ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref, _results1;
            _results1 = [];
            for (x = _j = 0, _ref = Math.floor(pos * rows * 2); 0 <= _ref ? _j < _ref : _j > _ref; x = 0 <= _ref ? ++_j : --_j) {
              if (x > 0 && x < cols) {
                _results1.push(clearImage(x, y));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      };
      renderMethod = function(pos) {
        ctx.save();
        return ctx.globalCompositeOperation = "lighter";
      };
      addAnimation(1000, beforeMethod, renderMethod, {
        done: callback
      });
      return null;
    };
    addAnimation = function(runTime, fncs) {
      var anim;
      anim = {
        runTime: runTime,
        startTime: Date.now(),
        pos: 0,
        fncs: fncs
      };
      animations.push(anim);
      return null;
    };
    renderAnimations = function(time, lastTime) {
      var anim, animTime, anims, i, n, _i, _j, _ref;
      anims = animations.slice(0);
      n = anims.length;
      if (n > 0) {
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          anim = anims[i];
          if (anim.fncs.before) {
            anim.fncs.before(anim.pos);
          }
          anim.lastPos = anim.pos;
          animTime = lastTime - anim.startTime;
          anim.pos = animTime / anim.runTime;
          anim.pos = Math.max(0, Math.min(1, anim.pos));
        }
        animations = [];
        for (i = _j = 0, _ref = n - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
          anim = anims[i];
          anim.fncs.render(anim.pos, anim.pos - anim.lastPos);
          if (anim.pos === 1) {
            if (anim.fncs.done) {
              anim.fncs.done();
            } else {
              animations.push(anim);
            }
          }
        }
      }
      return null;
    };
    createSolutionElement = function() {
      var $solutionElement, x, _i;
      $solutionElement = _$("#game-screen .solution");
      solutionCanvas = document.createElement("canvas");
      solutionCtx = solutionCanvas.getContext("2d");
      solutionCanvas.width = cols * imageSize;
      solutionCanvas.height = imageSize;
      solutionCtx.fillStyle = "rgba(255, 235, 255, 0.15)";
      for (x = _i = 0; 0 <= availableColoursCount ? _i < availableColoursCount : _i > availableColoursCount; x = 0 <= availableColoursCount ? ++_i : --_i) {
        if (x % 2 === 0) {
          solutionCtx.fillRect(x * imageSize, x * imageSize, imageSize, imageSize);
        }
        $solutionElement.append(solutionCanvas);
      }
      return null;
    };
    createAvailableColoursElement = function() {
      var $availableColourElement, availableColours, x, _i;
      $availableColourElement = _$("#game-screen .availableItems");
      availableColours = document.createElement("canvas");
      availableColorsCtx = availableColours.getContext("2d");
      availableColours.width = availableColoursCount * imageSize;
      availableColours.height = imageSize;
      availableColorsCtx.fillStyle = "rgba(255, 235, 255, 0.15)";
      for (x = _i = 0; 0 <= availableColoursCount ? _i < availableColoursCount : _i > availableColoursCount; x = 0 <= availableColoursCount ? ++_i : --_i) {
        if (x % 2 === 0) {
          availableColorsCtx.fillRect(x * imageSize, x * imageSize, imageSize, imageSize);
        }
        $availableColourElement.append(availableColours);
      }
      return null;
    };
    createBackground = function() {
      var background, bgCtx, x, y, _i, _j;
      background = document.createElement("canvas");
      bgCtx = background.getContext("2d");
      _$(background).addClass("background");
      background.width = cols * imageSize + imageSize;
      background.height = rows * imageSize;
      bgCtx.fillStyle = "rgba(255, 235, 255, 0.15)";
      for (x = _i = 0; 0 <= cols ? _i < cols : _i > cols; x = 0 <= cols ? ++_i : --_i) {
        for (y = _j = 0; 0 <= rows ? _j < rows : _j > rows; y = 0 <= rows ? ++_j : --_j) {
          if ((x + y) % 2 === 0) {
            bgCtx.fillRect(cols * imageSize, y * imageSize, imageSize, imageSize);
          }
        }
      }
      return background;
    };
    init = function($, callback) {
      setup($);
      callback();
      return null;
    };
    reset = function() {
      _options = App.settings;
      cols = _options.cols;
      rows = _options.rows;
      availableColoursCount = _options.availableColours;
      imageSize = _options.imageSize;
      canvas.width = canvas.width;
      hideSolution();
      return null;
    };
    drawSolution = function(guessColors) {
      var image, len, x, _i;
      image = images[imagePath];
      len = guessColors.length;
      for (x = _i = 0; 0 <= len ? _i < len : _i > len; x = 0 <= len ? ++_i : --_i) {
        solutionCtx.drawImage(image, guessColors[x] * imageSize, 0, imageSize, imageSize, x * imageSize, 0, imageSize, imageSize);
      }
      return null;
    };
    hideSolution = function() {
      solutionCanvas.width = solutionCanvas.width;
      return null;
    };
    drawAvailableColours = function() {
      var image, x, _i;
      image = images[imagePath];
      for (x = _i = 0; 0 <= availableColoursCount ? _i < availableColoursCount : _i > availableColoursCount; x = 0 <= availableColoursCount ? ++_i : --_i) {
        availableColorsCtx.drawImage(image, x * imageSize, 0, imageSize, imageSize, x * imageSize, 0, imageSize, imageSize);
      }
      return null;
    };
    drawCheckColors = function(correctColors) {
      var rightColor, rightPosition, rowNumber, x, z, _i, _j;
      rightColor = correctColors.rightColor;
      rightPosition = correctColors.rightPosition;
      rowNumber = correctColors.rowNumber;
      z = cols;
      ctx.fillStyle = "rgba(0, 12, 210, 0.15)";
      ctx.strokeStyle = "red";
      for (x = _i = 0; 0 <= rightColor ? _i < rightColor : _i > rightColor; x = 0 <= rightColor ? ++_i : --_i) {
        ctx.strokeRect(z * imageSize + x * imageSize / numColors, rowNumber * imageSize, imageSize / numColors, imageSize / 2);
        ctx.fillRect(z * imageSize + x * imageSize / numColors, rowNumber * imageSize, imageSize / numColors, imageSize / 2);
      }
      ctx.fillStyle = "red";
      ctx.strokeStyle = "rgba(0, 12, 210, 0.15)";
      for (x = _j = 0; 0 <= rightPosition ? _j < rightPosition : _j > rightPosition; x = 0 <= rightPosition ? ++_j : --_j) {
        ctx.strokeRect(z * imageSize + x * imageSize / numColors, rowNumber * imageSize + imageSize / 2, imageSize / numColors, imageSize / 2);
        ctx.fillRect(z * imageSize + x * imageSize / numColors, rowNumber * imageSize + imageSize / 2, imageSize / numColors, imageSize / 2);
      }
      return null;
    };
    myDrawImage = function(x, y, type) {
      var image;
      if (x === cols) {
        return null;
      }
      if (type === -1) {
        ctx.clearRect(x * imageSize, y * imageSize, imageSize, imageSize);
        return null;
      }
      image = images[imagePath];
      ctx.drawImage(image, type * imageSize, 0, imageSize, imageSize, x * imageSize, y * imageSize, imageSize, imageSize);
      return null;
    };
    renderCursor = function(x, y, opacity) {
      cursor = cursor || {};
      cursor.x = x;
      cursor.y = y;
      if (ctx) {
        opacity = opacity || 0.8;
        ctx.save();
        ctx.lineWidth = 0.05 * imageSize;
        ctx.strokeStyle = "rgba(250, 250, 150," + opacity + ")";
        ctx.strokeRect((x + 0.05) * imageSize, (y + 0.05) * imageSize, 0.9 * imageSize, 0.9 * imageSize);
        ctx.restore();
      }
      return null;
    };
    animateCursor = function(time) {
      var opacity;
      if (cursor) {
        opacity = 0.5 + (Math.sin(time / 400) + 1);
        renderCursor(cursor.x, cursor.y, opacity);
      }
      return null;
    };
    unRenderCursor = function(x, y, type) {
      if (ctx) {
        clearImage(x, y);
        myDrawImage(x, y, type);
      }
      return null;
    };
    clearImage = function(x, y) {
      if (x < 0 || x > cols || y < 0 || y > rows) {
        return null;
      }
      if (ctx) {
        ctx.save();
        ctx.clearRect(x * imageSize, y * imageSize, imageSize, imageSize);
        ctx.restore();
      }
      return null;
    };
    gameOver = function(callback) {
      var renderMethod;
      renderMethod = function(pos) {
        canvas.style.left = 0.2 * pos * (Math.random() - 0.5) + "em";
        return canvas.style.top = 0.2 * pos * (Math.random() - 0.5) + "em";
      };
      addAnimation(1000, {
        render: renderMethod,
        done: function() {
          canvas.style.left = "0";
          canvas.style.top = "0";
          return explode(callback);
        }
      });
      return null;
    };
    explode = function(callback) {
      alert('game over man :(');
      return null;
    };
    return {
      init: init,
      reset: reset,
      myDrawImage: myDrawImage,
      drawSolution: drawSolution,
      drawAvailableColours: drawAvailableColours,
      hideSolution: hideSolution,
      drawCheckColors: drawCheckColors,
      renderCursor: renderCursor,
      unRenderCursor: unRenderCursor,
      levelUp: levelUp,
      gameOver: gameOver
    };
  })();

}).call(this);

//# sourceMappingURL=display.canvas.js.map
